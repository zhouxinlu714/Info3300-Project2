<html><head>
    <title>INFO 3300/5100 - Project 2</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="color_legend.js"></script>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <style>
    body{
      background-color: black;
    }

    H1{
      font-family: 'Bebas Neue', cursive;
      font-size: 60px;
      color: #E50914;
      text-align: center;
    }
    .country {
      fill: rgb(227, 236, 240)
    }

    .outline {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }

    .graticule {
      stroke: darkgrey;
      stroke-width: 1px;
      fill: none;
    }

    .bar { fill: rgb(228, 61, 61); }
    </style>

</head>

<body>
  <h1>NETFLIX</h1>
  <svg id="choropleth" height="700" width="960" style="margin:20px" ></svg>
  <svg id="barchart" height="500" width="800" style="background:black"></svg>

    <script>
    // import color legend
    // import {legend, swatches} from "@d3/color-legend"
    // import d3_colorLegend from "https://api.observablehq.com/@d3/color-legend.js?v=3";
    // import "color_legend.js";

    const svg = d3.select("#choropleth");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 40, left:20};
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
                    .attr("transform","translate("+margin.left+","+margin.top+")");

    //rating bar chart
    const rating_svg = d3.select("#barchart");
    const width2 = rating_svg.attr("width");
    const height2 = rating_svg.attr("height");
    const margin2 = { top: 50, right: 50, bottom: 20, left:60};
    const ratingWidth = width2 - margin2.left - margin2.right;
    const ratingHeight = height2  - margin2.top - margin2.bottom;
    const rating_barchart = rating_svg.append("g")
                    .attr("transform","translate("+margin2.left+","+margin2.top+")");


    const requestData = async function (){

      // world countries data
      var countries_topo = await d3.json("./countries-110m.json");

      // filter out Antarctica and Greenland
      var filtered_countries = countries_topo.objects.countries.geometries;
      filtered_countries = filtered_countries.filter(
        d => d.properties.name !== "Antarctica" &&  d.properties.name !== "Greenland"
      );
      countries_topo.objects.countries.geometries = filtered_countries;

      //  projecton and path for world countries
      var countries = topojson.feature(countries_topo, countries_topo.objects.countries);
      var countriesMesh = topojson.mesh(countries_topo, countries_topo.objects.countries);
      var landMesh = topojson.mesh(countries_topo, countries_topo.objects.land);
      console.log("countries", countries);


      var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);
      var graticule = d3.geoGraticule10();
      // map.append("path").attr("class","graticule").attr("d", path(graticule) )

      // clean netflix data
      const netflix_titles = await d3.csv("./netflix_titles.csv");
      console.log(netflix_titles);

      // year added extent
      const year_added_extent = d3.extent(netflix_titles, d => d.date_added.split(', ')[1]);

      // create a dictionary for each valid year called data, in the form of
      // data = {... 2019:{num_titles:30, num_countries:2, count:{country:20, country2:10}}...}
      var data = {};
      for (i = year_added_extent[0]; i <= year_added_extent[1]; i++) {
        data[i] = {};
        data[i]["num_titles"] = 0;
        data[i]["num_countries"] = 0;
        data[i]["num_genres"] = 0;
        data[i]["num_ratings"] = 0;
        data[i]["countriesCount"] = {};
        data[i]["genresCount"] = {};
        data[i]["ratingsCount"] = {};
      }

      data['All_year'] = {};
      data['All_year']["ratingsCount"] = {};
      // console.log(data)
      netflix_titles.forEach( (d, i) => {
        if ((d.country === "")|| (d.date_added === "") || (d['listed_in'] === "")|| (d.rating === ""))  {
          netflix_titles.splice(i, 1);
        }
        else {
          year_added = d.date_added.split(', ')[1];
          data[year_added]["num_titles"] += 1;

          let release_countries = (d.country).split(', ');
          let dict = data[year_added]["countriesCount"];
          release_countries.forEach( (country, i) => {
            if (country === "United States") country = "United States of America";
            if (country === "Czech Republic") country = "Czechia";
            if (country in dict){
              dict[country] += 1;
            } else{
              dict[country] = 1;
              data[year_added]["num_countries"] += 1;
            };
          });

          let genres = d['listed_in'].split(", ");
          let genreDict = data[year_added]["genresCount"];
          genres.forEach( (genre,i) => {
            if (genre in genreDict) {
              genreDict[genre] += 1;
            }
            else {
              genreDict[genre] = 1;
              data[year_added]["num_genres"] += 1;
            };
          });

          let rating = d.rating;
          let ratingDict = data[year_added]["ratingsCount"];
          if (rating in ratingDict) {
            ratingDict[rating] += 1;
          }
          else {
            ratingDict[rating] = 1;
            data[year_added]["num_ratings"] += 1;
          };

          //count rating for whole years
          let Allyear_ratingDict = data['All_year']["ratingsCount"];
          if (rating in Allyear_ratingDict) {
            Allyear_ratingDict[rating] += 1;
          }
          else {
            Allyear_ratingDict[rating] = 1;
          };
        };
      });
      console.log("final data", data);

      // draw countries
      map.selectAll("path.country")
         .data(countries.features.filter(d => d.properties.name !== "Antarctica"
                                     &&  d.properties.name !== "Greenland"))
         .join("path")
         .attr("class", "country")
         .attr("note", (d, i) => d.properties.name )
         .attr("d", path);

      map.append("path").datum(countriesMesh)
         .attr("class","outline")
         .attr("d", path);

      // 2020 data
      data2020 = data["2020"];
      console.log(data2020);

      // make colorscale based on title count in all years
      var total_minMax = [0,0];
      for (i = year_added_extent[0]; i <= year_added_extent[1]; i++) {
        let num_titles_values =  Object.values(data[i].countriesCount) ;
        let minMax = d3.extent(num_titles_values);
        if (minMax[1] > total_minMax[1]) total_minMax = [0, minMax[1]];
      };
      const colorScale = d => d3.interpolateReds( d3.scaleSymlog()
                                .domain([0, total_minMax[1]]).range([0,1])(d) );

      var countries_count = data2020.countriesCount;
      function titles_count (ctry) {
        if (ctry in countries_count){
          count = countries_count[ctry];
        } else {
          count = 0;
        };
        return count;
      };

      map.selectAll(".country")
         .style("fill", d => colorScale(titles_count(d.properties.name)) );

     // draw color legend
     var legend_x = d3.scaleSymlog()
                     .domain([0, total_minMax[1]])
                     .range([margin.left+mapWidth*0.05, margin.left+mapWidth*0.9]);

     map.append("g")
         .attr("transform", `translate(0,${height-margin.bottom})`)
         .call(rampHorizontal(legend_x, colorScale))
         .call(d3.axisBottom(legend_x));


      //bar chart
      //dict => array
      let Allyear_ratingDict = data['All_year']['ratingsCount']
      console.log(Object.entries(Allyear_ratingDict))
      let ratingArray = [];
      for (const [rating, value] of Object.entries(Allyear_ratingDict)) {
        ratingArray.push({
          'rating': rating,
          'value': value
        })
      }
      console.log(ratingArray)
      ratingArray = ratingArray.sort(function (a, b) {
            return d3.ascending(a.value, b.value);
        })

      var y = d3.scaleBand()
          .domain(ratingArray.map(function(d) { return d.rating; }))
          .range([ratingHeight, 0])
          .padding(0.1);

      var x = d3.scaleLinear()
          .domain([0, d3.max(ratingArray, function(d){ return d.value; })])
          .range([0, ratingWidth]);

      var bars = rating_barchart.selectAll(".bar")
        .data(ratingArray)
        .enter()
        .append("g");

      bars.append("rect").attr("class", "bar")
        .attr("width", function(d) {return x(d.value); } )
        .attr("y", function(d) { return y(d.rating); })
        .attr("height", y.bandwidth());

      let leftAxis = d3.axisLeft(y).tickSize(0);
      rating_barchart.append("g")
                .attr("class", "y axis")
                .attr("color", 'white')
                .call(leftAxis);

      bars.append("text")
        .attr("class", "value")
        .text(function(d) { console.log(d.value); return d.value;})
        .attr("x", function(d){ return x(d.value) + 15;})
        .attr("y", function(d){return y(d.rating) + y.bandwidth() * (0.5 + 0.1);})
        .style("font-family" , "Arial")
        .style("font-size", "13px")
        .style("fill", "white")
        .attr("text-anchor", "middle");

       // add title
       rating_svg.append("text")
                .attr("x", width2 / 2)
                .attr("y", margin2.top / 2 )
                .attr("text-anchor", "middle")
                .style("font-family" , "Arial")
                .style("font-size", "20px")
                .style("fill", "white")
                .text("MOVIE AND TV SHOWS BY RATING");


    }
    requestData();
    </script>

</body>

</html>
