<html>

<head>
  <title>INFO 3300/5100 - Project 2</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="color_legend.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/d3-simple-slider"></script>
  <style>
    body {
      background-color: black;
      font-family: Arial, Helvetica, sans-serif;
      position: relative;
    }

    H1 {
      font-family: 'Bebas Neue', cursive;
      font-size: 60px;
      color: #E50914;
      text-align: center;
    }

    H2{
      font-family: 'Bebas Neue', cursive;
      font-size: 30px;
      color: white;
      text-align: center;
    }

    .country {
      fill: rgb(227, 236, 240)
    }

    .outline {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }

    .graticule {
      stroke: darkgrey;
      stroke-width: 1px;
      fill: none;
    }

    .bar {
      fill: rgb(228, 61, 61);
    }

    .gridlines line {
      stroke: grey;
    }

    .gridlines .domain {
      stroke: none;
    }

    .tooltip {
      font: 12px Helvetica;
    }

    .legend_axis line{
      stroke: white;
    }

    .legend_axis path{
      stroke: white;
    }

    .legend_axis text{
      fill: white;
    }

    .legend_label {
      font: italic 16px serif;
      fill: rgb(237, 77, 77);
    }

    .slider_label {
      font: bold 15px serif;
      fill: rgb(255, 71, 71);
    }

    .axis text,
    .slider text {
      font-size: 15px;
    }

    .axis text {
      fill: grey;
    }

    .slider text {
      fill: rgb(255, 71, 71);
    }

    .bar { fill: rgb(228, 61, 61); }

    </style>

</head>

<body>
  <h1>NETFLIX MOVIES AND TV SHOWS</h1>
  <h2>Info 3300 Project 2</h2>
  <div id="slider" style="margin:50px"></div>
  <svg id="choropleth" height="700" width="960" style="margin:20px"></svg>
  <h2> TOP 5 GENRES BY YEAR</h2>
  <svg id="bubble" height="400" width="940" style="margin:10px" ></svg>
  <div id="barchartBody"><svg id="barchart" height="700" width="960" style="margin:20px"></svg></div>
  <svg id="piechart" height="450" width="450" style="margin:20px"></svg>

    <script>

    // Setting up the map
    const svg = d3.select("#choropleth");
    const slider = d3.select('div#slider');
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 40, left: 20 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Setting up the bubble chart
    const bubble = d3.select("#bubble");
    const bWidth = bubble.attr("width");
    const bHeight = bubble.attr("height");
    const bMargin = { top: 20, right: 10, bottom: 10, left:10};
    const chartWidth = bWidth - bMargin.left - bMargin.right;
    const chartHeight = bHeight - bMargin.top - bMargin.bottom;
    const bubbleChart = bubble.append("g")
                    .attr("transform","translate("+bMargin.left+","+bMargin.top+")");

    //rating bar chart
    const svg2 = d3.select("#barchart");
    const width2 = svg2.attr("width");
    const height2 = svg2.attr("height");
    const margin2 = { top: 100, right: 100, bottom: 60, left: 150 };
    const ratingWidth = width2 - margin2.left - margin2.right;
    const ratingHeight = height2 - margin2.top - margin2.bottom;
    const rating_barchart = svg2.append("g")
      .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    var margin3 = { top: 10, right: 10, bottom: 10, left: 10 },
      width3 = 450 - margin3.left - margin3.right,
      height3 = 450 - margin3.top - margin3.bottom;

    const requestData = async function () {

      // world countries data
      var countries_topo = await d3.json("./countries-110m.json");

      // filter out Antarctica and Greenland
      var filtered_countries = countries_topo.objects.countries.geometries;
      filtered_countries = filtered_countries.filter(
        d => d.properties.name !== "Antarctica" && d.properties.name !== "Greenland"
      );
      countries_topo.objects.countries.geometries = filtered_countries;

      //  projection and path for world countries
      var countries = topojson.feature(countries_topo, countries_topo.objects.countries);
      var countriesMesh = topojson.mesh(countries_topo, countries_topo.objects.countries);
      var landMesh = topojson.mesh(countries_topo, countries_topo.objects.land);
      // console.log("countries", countries);


      var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);
      var graticule = d3.geoGraticule10();
      // map.append("path").attr("class","graticule").attr("d", path(graticule) )

      // clean netflix data 7787==>7265
      let netflix_titles = await d3.csv("./netflix_titles.csv");
      netflix_titles = netflix_titles.filter((d) => { return d['country'] != '' && d['rating'] != '' && d['date_added'] != '' });
      console.log(netflix_titles);


      // year added extent
      const year_added_extent = d3.extent(netflix_titles, d => d.date_added.split(', ')[1]);
      // console.log("added year extent", year_added_extent)


      // create a dictionary for each valid year called data, in the form of
      // data = {... 2019:{num_titles:30, num_countries:2, count:{country:20, country2:10}}...}
      var data = {};
      for (i = year_added_extent[0]; i <= year_added_extent[1]; i++) {
        data[i] = {};
        data[i]["num_titles"] = 0;
        data[i]["num_countries"] = 0;
        data[i]["num_genres"] = 0;
        data[i]["num_ratings"] = 0;
        data[i]["countriesCount"] = {};
        data[i]["genresCount"] = {};
        data[i]["ratingsCount"] = {};
        data[i]["ratingByCountry"] = {};
      }

      // initiate data for all years
      data['All_year'] = {};
      data['All_year']["num_titles"] = 0;
      data['All_year']["num_countries"] = 0;
      data['All_year']["num_genres"] = 0;
      data['All_year']["num_ratings"] = 0;
      data['All_year']["countriesCount"] = {};
      data['All_year']["genresCount"] = {};
      data['All_year']["ratingsCount"] = {};
      data['All_year']["ratingByCountry"] = {};

      netflix_titles.forEach((d, i) => {

        year_added = d.date_added.split(', ')[1];
        data[year_added]["num_titles"] += 1;
        data['All_year']["num_titles"] += 1;

        let release_countries = (d.country).split(', ');
          let dict = data[year_added]["countriesCount"];
          let dict_all = data['All_year']["countriesCount"];
          release_countries.forEach( (country, i) => {
            if (country === "United States") country = "United States of America";
            if (country === "Czech Republic") country = "Czechia";
            if (country in dict){
              dict[country] += 1;
            } else{
              dict[country] = 1;
              data[year_added]["num_countries"] += 1;
            };
            if (country in dict_all){
              dict_all[country] += 1;
            } else{
              dict_all[country] = 1;
              data['All_year']["num_countries"] += 1;
            };
          });

          let genres = d['listed_in'].split(", ");
          let genreDict = data[year_added]["genresCount"];
          let genreDict_all = data["All_year"]["genresCount"];
          genres.forEach( (genre,i) => {
            if (genre in genreDict) {
              genreDict[genre] += 1;
            }
            else {
              genreDict[genre] = 1;
              data[year_added]["num_genres"] += 1;
            };
            if (genre in genreDict_all) {
              genreDict_all[genre] += 1;
            }
            else {
              genreDict_all[genre] = 1;
              data['All_year']["num_genres"] += 1;
            };
          });

        let rating = d.rating;
        let ratingDict = data[year_added]["ratingsCount"];
        if (rating in ratingDict) {
          ratingDict[rating] += 1;
        }
        else {
          ratingDict[rating] = 1;
          data[year_added]["num_ratings"] += 1;
        };

        //count rating for whole years
        let Allyear_ratingDict = data['All_year']["ratingsCount"];
        if (rating in Allyear_ratingDict) {
          Allyear_ratingDict[rating] += 1;
        }
        else {
          Allyear_ratingDict[rating] = 1;
        };

        let dict1 = data[year_added]["ratingByCountry"];
        release_countries.forEach((country, i) => {
          let rating = d.rating;
          if (country === "United States") country = "United States of America";
          if (country === "Czech Republic") country = "Czechia";
          if (country in dict1) {
            if (rating in dict1[country]) {
              dict1[country][rating] += 1;
            }
            else {
              dict1[country][rating] = 1;
            }
          } else {
            dict1[country] = {}
            dict1[country][rating] = 1
          }

          // let rating = d.rating;/
          let ratingDict = data[year_added]["ratingsCount"];
          if (rating in ratingDict) {
            ratingDict[rating] += 1;
          }
          else {
            ratingDict[rating] = 1;
            data[year_added]["num_ratings"] += 1;
          };

          //count rating for whole years
          let Allyear_ratingDict = data['All_year']["ratingsCount"];
          if (rating in Allyear_ratingDict) {
            Allyear_ratingDict[rating] += 1;
          }
          else {
            Allyear_ratingDict[rating] = 1;
            data['All_year']['num_ratings']+=1;
          };
        });
      });

      // console.log(data);

      for (const year_added in data) {
        for (const genresCount in year_added) {
            var topFive = Object.keys(data[year_added]["genresCount"]).map(function(key) {
                return [key, data[year_added]["genresCount"][key]];
            });
            
            topFive.sort(function(first, second) {
                return second[1] - first[1];
            });
        }
        // console.log(year_added, topFive.slice(0, 5));
        };

      // console.log("final data", data);

      console.log("final data", data);
      console.log(data)
      // draw countries
      map.selectAll("path.country")
        .data(countries.features.filter(d => d.properties.name !== "Antarctica"
          && d.properties.name !== "Greenland"))
        .join("path")
        .attr("class", "country")
        .attr("note", (d, i) => d.properties.name)
        .attr("d", path);

      map.append("path").datum(countriesMesh)
        .attr("class", "outline")
        .attr("d", path);

      // 2020 data
      data2020 = data["2020"];
      console.log(data2020)
      // Added year slider
      var dataTime = d3.range(2008, 2022).map(function(d) {
        return new Date(d, 4, 26);
      });

      var sliderTime = d3
        .sliderBottom()
        .min(d3.min(dataTime))
        .max(d3.max(dataTime))
        .step(1000 * 60 * 60 * 24 * 365)
        .width(800)
        .tickFormat(d3.timeFormat('%Y'))
        .tickValues(dataTime)
        .default(new Date(2021, 4, 26))
        .on('onchange', val => {
          let current_year = d3.timeFormat('%Y')(val);
          draw_map(current_year);
          d3.select('p#value-time').text(current_year);
          drawCircles(current_year);
        });

      var Time = slider
        .append('svg')
        .attr('width', 900)
        .attr('height', 100)
        .append('g')
        .attr('transform', 'translate(30,30)');

      Time.call(sliderTime);
      d3.select('p#value-time').text(d3.timeFormat('%Y')(sliderTime.value()));

      slider.select('svg').append("text")
         .attr("x", 10)
         .attr("y", 10)
         .attr("class", "slider_label")
         .text("Use this slider to update all charts based on your year selection");

      // make colorscale based on title count in all years
      var total_minMax = [0, 0];
      for (i = year_added_extent[0]; i <= year_added_extent[1]; i++) {
        let num_titles_values = Object.values(data[i].countriesCount);
        let minMax = d3.extent(num_titles_values);
        if (minMax[1] > total_minMax[1]) total_minMax = [0, minMax[1]];
      };
      const colorScale = d => d3.interpolateReds(d3.scaleSymlog()
        .domain([0, total_minMax[1]]).range([0, 1])(d));

      // draw map
      // interaction function based on selected year
      function draw_map(current_year){
        let current_data = data[current_year];
        let countries_count = current_data.countriesCount;
        map.selectAll(".country")
           .style("fill", d => colorScale(titles_count(d.properties.name, countries_count)) );
      };

      // default map is based on netflix data in 2021
      draw_map("2021");

      function titles_count (ctry, countries_count) {
        if (ctry in countries_count){
          count = countries_count[ctry];
        } else {
          count = 0;
        };
        return count;
      };

     // draw color legend
     var legend_x = d3.scaleSymlog()
                     .domain([0, total_minMax[1]])
                     .range([margin.left+mapWidth*0.05, margin.left+mapWidth*0.9]);

     map.append("g")
           .attr("transform", `translate(0,${height-margin.bottom})`)
           .attr("class", "legend_axis")
           .call(rampHorizontal(legend_x, colorScale))
           .call(d3.axisBottom(legend_x))
         .selectAll("text")
           .attr("dy", ".35em")
           .attr("transform", "rotate(50)")
           .style("text-anchor", "start");

     map.append("text")
        .attr("x", margin.left+mapWidth*0.04)
        .attr("y", height-margin.bottom-30)
        .attr("class", "legend_label")
        .text("Title count (per country):");

     // create title for bubble chart
     bubble.append("text")
                .attr("x", bWidth / 2)
                .attr("y", bMargin.top-5)
                .attr("text-anchor", "middle")
                .style("font-family" , "'Bebas Neue', cursive")
                .style("font-size", "20px")
                .style("fill", "white")
                .text("TOP 5 GENRES FOR SELECTED YEAR");
     
     // Calculate the top 5 genres for each year
     let genreObj = {};
     for (let year_added in data) {
        for (let genresCount in year_added) {
            var topFive = Object.keys(data[year_added]["genresCount"]).map(function(key) {
                return [key, data[year_added]["genresCount"][key]];
            });
            
            topFive.sort(function(first, second) {
                return second[1] - first[1];
            });
        }
        genreObj[year_added] = topFive.slice(0, 5);
      };
      console.log(genreObj)

      // default circles are based on 2021
      drawCircles(2021);
      
      // build scales
      // let genreExtent = []
      // genreExtent.push(genreObj[slideryear][genreObj[slideryear].length-1][1])
      // genreExtent.push(genreObj[slideryear][0][1])
      // console.log(genreExtent)

      // const genreScale = d3.scaleLinear().domain(genreExtent).range([40,80]);
      // color of circles based on genre
      // const typeScale = d3.scaleOrdinal().domain(["genre1","genre2"]).range(["#color","#color"]);

      // draw circles
      function drawCircles (slideryear) {
        let bubblePack = d => d3.pack()
                                    .size([chartWidth,chartHeight])
                                    .padding(2)(d3.hierarchy({children:genreObj[slideryear]}).sum(d => d[1]))
        
        let root = bubblePack(genreObj[slideryear]);
        
        let node = bubbleChart.selectAll('circle.genre')
                                .data(root.children)
                                // .enter().append('g')
                                .join("circle").attr("class","genre")
                                .attr("r", d => d.r)
                                .style('fill','red')
                                .attr("label", d => d.data)
                                .attr('transform', d => `translate(${d.x}, ${d.y})`);

        let labels = bubbleChart.selectAll('text.label')
                                .data(root.children)
                                .join("text").attr("class","label")
                                .text(d => d.data)
                                // .text(d => d.data[0].substring(0,8))
                                .style("font-size",15)
                                .style("fill","white")
                                .attr('transform', d => `translate(${d.x-20}, ${d.y})`);
      }


    // .data.name.substring(0, d.r / 3)

      //bar chart
      let annotations = svg2.append("g").attr("id", "annotations");
      var Rating_Age = ["Little Kids", "Kids", "Teen", "Adult"];
      var stack = d3.stack()
        .keys(Rating_Age)
        .order(d3.stackOrderDescending)
        .offset(d3.stackOffsetNone);

      for (const [country, ratings] of Object.entries(data2020.ratingByCountry)) {
        ratings['Country'] = country
      }

      let stacked_data = Object.values(data2020.ratingByCountry)
      let ratings = Object.keys(data2020.ratingsCount)

      const RATING_MAP = {
        "TV-MA": "Adult",
        "R": "Adult",
        "NC-17": "Adult",
        "TV-14": "Teen",
        "PG-13": "Teen",
        "TV-PG": "Kids",
        "TV-Y7": "Kids",
        "PG": "Kids",
        "TV-Y7-FV": "Kids",
        "G": "Little Kids",
        "TV-Y": "Little Kids",
        "TV-G": "Little Kids"
      }
      let stacked_data2 = []
      stacked_data.forEach((d) => {
        let new_dict = {
          "Adult": 0,
          "Teen": 0,
          "Kids": 0,
          "Little Kids": 0
        }

        for (const [key, value] of Object.entries(d)) {
          if (key === 'Country') {
            new_dict[key] = value;
          }
          else if (key in RATING_MAP) {
            new_dict[RATING_MAP[key]] += value;
          }
        }
        stacked_data2.push(new_dict);
      });

      stacked_data2.sort(function (first, second) {
        let first_total = Object.values(first).filter(v => !isNaN(v)).reduce((a, b) => a + b, 0);
        let second_total = Object.values(second).filter(v => !isNaN(v)).reduce((a, b) => a + b, 0);
        return d3.ascending(first_total, second_total);
      })

      if (stacked_data2.length >= 10) {
        stacked_data2 = stacked_data2.slice(Math.max(stacked_data2.length - 10, 1))
      }

      console.log(stacked_data2)

      maxNum = d3.max(Object.values(data2020['countriesCount']))
      const xScale = d3.scaleLinear().domain([0, maxNum]).range([0, ratingWidth]);

      var countryNames = stacked_data2.map(d => d.Country);
      const yScale = d3.scaleBand().domain(countryNames).range([ratingHeight, 0])
        .padding(0.2);

      let leftAxis = d3.axisLeft(yScale);
      let leftGridlines = d3.axisLeft(yScale)
        .tickSize(-ratingWidth - 20)
        .tickFormat("")

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (margin2.left) + "," + margin2.top + ")")
        .attr("color", 'white')
        .call(leftAxis);

      let bottomAxis = d3.axisBottom(xScale).ticks(7);
      let bottomGridlines = d3.axisBottom(xScale)
        .tickSize(-ratingHeight - 20)
        .tickFormat("");

      annotations.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(" + margin2.left + "," + (ratingHeight + margin2.top + 20) + ")")
        .attr("color", 'white')
        .call(bottomAxis);

      annotations.append("g")
        .attr("class", "x gridlines")
        .attr("transform", "translate(" + margin2.left + "," + (ratingHeight + margin2.top + 20) + ")")
        .attr("color", 'white')
        .call(bottomGridlines);

      let series = stack(stacked_data2);
      const color1 = d3.scaleOrdinal().domain(Object.keys(data2020.ratingsCount)).range(d3.schemeTableau10);
      const color = d3.scaleOrdinal().domain(Rating_Age).range(d3.schemeReds[4]);
      let rects = rating_barchart.selectAll("g").data(series).enter()
        .append("g")
        .attr("fill", d => color(d.key));



      var tooltip = d3.select("#barchartBody").append("div")
        .append("div")
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "1px")
        .style("border-radius", "5px")
        .style("padding", "10px")
        .style("position", "absolute")
        .style("display", "none");

      var mouseover = function (d) {
        d3.select(this)
          .style("stroke", "white")
        tooltip.style("left", d.pageX + 10 + "px")
          .style("top", d.pageY - 25 + "px")
          .style("display", "inline-block")
          .html(d3.select(this.parentNode).datum().key + ": " + d3.select(this).attr("label"));
      }

      var mousemove = function (d) {
        tooltip
          .style("left", (d3.select(this)[0] + 90) + "px")
          .style("top", (d3.select(this)[1]) + "px")
      }

      var mouseleave = function (d) {
        tooltip.style("display", "none");
        d3.select(this)
          .style("stroke", "none")
      }


      rects.selectAll("rect")
        .data(d => d)
        .join("rect")
        .attr("x", d => xScale(d[0]))
        .attr("y", (d, i) => yScale(d.data.Country))
        .attr("width", d => {
          let width;
          if (d[1] === undefined || xScale(d[1]) === undefined) {
            width = 0;
          } else if (d[0] === undefined || xScale(d[0]) === undefined) {
            width = xScale(d[1]);
          } else {
            width = xScale(d[1]) - xScale(d[0]);
          }
          return width;
        })
        .attr("height", yScale.bandwidth())
        .attr("label", d => d[1] - d[0])
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave);


      /// add title
      svg2.append("text")
        .attr("x", width2 / 2)
        .attr("y", margin2.top / 2)
        .attr("text-anchor", "middle")
        .style("font-family", "Arial")
        .style("font-size", "20px")
        .style("fill", "white")
        .text("MOVIE AND TV SHOWS RATINGS BY COUNTRY");

      // Add X axis label:
      svg2.append("text")
        .attr("text-anchor", "end")
        .attr("x", width2 - 100)
        .attr("y", height2 - 10)
        .style("fill", "white")
        .text("Titles");

      // Y axis label:
      svg2.append("text")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-90)")
        .attr("y", margin2.left - 15)
        .attr("x", -margin2.top + 40)
        .style("fill", "white")
        .text("Country")

      //add legend
      var size = 20
      var Age_legend = svg2.append('g')
        .attr('class', 'Age_legend')
        .attr('transform', 'translate(' + 350 + ',' + (height2 - 400) + ')')
        .style("margin-bottom", "5px");

      Age_legend.selectAll('rect')
        .data(Rating_Age)
        .enter()
        .append('rect')
        .attr('x', 510)
        .attr('y', function (d, i) {
          return i * (size + 5)
        })
        .attr('width', size)
        .attr('height', size)
        .attr('fill', function (d, i) {
          return color(i);
        });

      // Add one dot in the legend for each name.
      Age_legend.selectAll("mylabels")
        .data(Rating_Age)
        .enter()
        .append("text")
        .attr("x", 510 + size * 1.2)
        .attr("y", function (d, i) { return i * (size + 5) + (size / 2) })
        .style("fill", function (d) { return color(d) })
        .text(function (d) { return d })
        .attr("text-anchor", "left")
        .style("alignment-baseline", "middle")

      //pie chart
      var pie_svg = d3.select("#piechart").append("svg")
        .append("g")
        .attr("transform", "translate(" + width3 / 2 + "," + height3 / 2 + ")");

      var pie = d3.pie()
        .value(function (d) { return d.value; })

      let pieData = [];
      for (const obj of Object.entries(data2020.ratingsCount)) {
        let data = {
          "key": obj[0],
          "value": obj[1],
        };
        pieData.push(data);
      }
      var data_ready = pie(pieData);
      var radius = Math.min(width3, height3) / 4;

      // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
      var arcGenerator = d3.arc()
        .innerRadius(0)
        .outerRadius(radius)

      const labelOffset = radius * 1.4;
      const arcLabel = d3.arc()
        .innerRadius(labelOffset)
        .outerRadius(labelOffset);

      pie_svg
        .selectAll('whatever')
        .data(data_ready)
        .enter()
        .append('path')
        .attr('d', arcGenerator)
        .attr('fill', function (d) { return color1(d.data.key) })
        .attr("stroke", "white")
        .style("stroke-width", "2px")
        .style("opacity", 1)

      const labels = pie_svg.selectAll('text')
        .data(data_ready)
        .enter()
        .append('text')
        .style('text-anchor', 'middle')
        .style('alignment-baseline', 'middle')
        .style('font-size', '15px')
        .attr('transform', d => `translate(${arcLabel.centroid(d)})`)

      labels.append('tspan')
        .attr('y', '-0.6em')
        .attr('x', 0)
        .style('font-weight', 'bold')
        .style("fill", "white")
        .text(d => `${d.data.key}`);

      labels.append('tspan')
        .attr('y', '0.6em')
        .attr('x', 0)
        .style("fill", "white")
        .text(d => `${d.data.value} (${Math.round(d.data.value / data2020.num_titles * 100)}%)`);

    }
    requestData();
  </script>

</body>

</html>