<html><head>
    <title>INFO 3300/5100 - Project 2</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
    .country {
      fill: rgb(227, 236, 240)
    }

    .outline {
      stroke: white;
      stroke-width: 1px;
      fill: none;
    }

    .graticule {
      stroke: #ECEDED;
      stroke-width: 1px;
      fill: none;
    }
    </style>

</head>

<body>
  <svg id="choropleth" height="650" width="960" style="margin:20px" ></svg>

    <script>
    // import color legend
    // import {legend, swatches} from "@d3/color-legend"
    // import d3_colorLegend from "https://api.observablehq.com/@d3/color-legend.js?v=3";

    const svg = d3.select("#choropleth");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 20, left:20};
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
                    .attr("transform","translate("+margin.left+","+margin.top+")");

    const requestData = async function (){

      // world countries data
      var countries_topo = await d3.json("./countries-110m.json");

      // filter out Antarctica and Greenland
      var filtered_countries = countries_topo.objects.countries.geometries;
      filtered_countries = filtered_countries.filter(
        d => d.properties.name !== "Antarctica" &&  d.properties.name !== "Greenland"
      );
      countries_topo.objects.countries.geometries = filtered_countries;

      //  projecton and path for world countries
      var countries = topojson.feature(countries_topo, countries_topo.objects.countries);
      var countriesMesh = topojson.mesh(countries_topo, countries_topo.objects.countries);
      var landMesh = topojson.mesh(countries_topo, countries_topo.objects.land);
      console.log("countries", countries);


      var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);
      var graticule = d3.geoGraticule10();
      map.append("path").attr("class","graticule").attr("d", path(graticule) )

      // clean netflix data
      const netflix_titles = await d3.csv("./netflix_titles.csv");
      console.log(netflix_titles);

      // year added extent
      const year_added_extent = d3.extent(netflix_titles, d => d.date_added.split(', ')[1]);

      // create a dictionary for each valid year called data, in the form of
      // data = {... 2019:{num_titles:30, num_countries:2, count:{country:20, country2:10}}...}
      var data = {};
      for (i = year_added_extent[0]; i <= year_added_extent[1]; i++) {
        data[i] = {};
        data[i]["num_titles"] = 0;
        data[i]["num_countries"] = 0;
        data[i]["num_genres"] = 0;
        data[i]["countriesCount"] = {};
        data[i]["genresCount"] = {};
      }

      netflix_titles.forEach( (d, i) => {
        if ((d.country === "")|| (d.date_added === "") || (d['listed_in'] === ""))  {
          netflix_titles.splice(i, 1);
        }
        else {
          year_added = d.date_added.split(', ')[1];
          data[year_added]["num_titles"] += 1;

          let release_countries = (d.country).split(', ');
          let dict = data[year_added]["countriesCount"];
          release_countries.forEach( (country, i) => {
            if (country === "United States") country = "United States of America";
            if (country === "Czech Republic") country = "Czechia";
            if (country in dict){
              dict[country] += 1;
            } else{
              dict[country] = 1;
              data[year_added]["num_countries"] += 1;
            };
          });

          let genres = d['listed_in'].split(", ");
          let genreDict = data[year_added]["genresCount"];
          genres.forEach( (genre,i) => {
            if (genre in genreDict) {
              genreDict[genre] += 1;
            }
            else {
              genreDict[genre] = 1;
              data[year_added]["num_genres"] += 1;
            };
          });
        };

      });
      console.log("final data", data);

      // draw countries
      map.selectAll("path.country")
         .data(countries.features.filter(d => d.properties.name !== "Antarctica"
                                     &&  d.properties.name !== "Greenland"))
         .join("path")
         .attr("class", "country")
         .attr("note", (d, i) => d.properties.name )
         .attr("d", path);

      map.append("path").datum(countriesMesh)
         .attr("class","outline")
         .attr("d", path);

      // 2020 data
      data2020 = data["2021"];
      console.log(data2020);

      // make colorscale based on title count in all years
      var total_minMax = [0,0];
      for (i = year_added_extent[0]; i <= year_added_extent[1]; i++) {
        let num_titles_values =  Object.values(data[i].countriesCount) ;
        let minMax = d3.extent(num_titles_values);
        if (minMax[1] > total_minMax[1]) total_minMax = [0, minMax[1]];
      };
      const colorScale = d => d3.interpolateReds( d3.scaleSymlog()
                                .domain([0, total_minMax[1]]).range([0,1])(d) );

      var countries_count = data2020.countriesCount;
      function titles_count (ctry) {
        if (ctry in countries_count){
          count = countries_count[ctry];
        } else {
          count = 0;
        };
        return count;
      };

      map.selectAll(".country")
         .style("fill", d => colorScale(titles_count(d.properties.name)) );

      // legend({
      //   color: d3.scaleSymlog([0, total_minMax[1]], d3.interpolateReds),
      //   title: "Title Count",
      //   ticks: 10
      //   // tickFormat: ".0s"
      // })


      // drawLegend(d3.select("#colorLegend"), colorScale);

    }
    requestData();
    </script>

</body>

</html>
