<html><head>
    <title>INFO 3300/5100 - Project 2</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="color_legend.js"></script>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/d3-simple-slider"></script>
    <style>
    body{
      background-color: black;
    }

    H1{
      font-family: 'Bebas Neue', cursive;
      font-size: 60px;
      color: #E50914;
      text-align: center;
    }

    H2{
      font-family: 'Bebas Neue', cursive;
      font-size: 30px;
      color: white;
      text-align: center;
    }

    .country {
      fill: rgb(227, 236, 240)
    }

    .outline {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }

    .graticule {
      stroke: darkgrey;
      stroke-width: 1px;
      fill: none;
    }

    .legend_axis line{
      stroke: white;
    }

    .legend_axis path{
      stroke: white;
    }

    .legend_axis text{
      fill: white;
    }

    .legend_label {
      font: italic 16px serif;
      fill: rgb(237, 77, 77);
    }

    .slider_label {
      font: bold 15px serif;
      fill: rgb(255, 71, 71);
    }

    .axis text,
    .slider text {
      font-size: 15px;
    }

    .axis text {
      fill: grey;
    }

    .slider text {
      fill: rgb(255, 71, 71);
    }

    .bar { fill: rgb(228, 61, 61); }

    </style>

</head>

<body>
  <h1>NETFLIX MOVIES AND TV SHOWS</h1>
  <div id="slider" style="margin:50px"></div>
  <svg id="choropleth" height="700" width="940" style="margin:10px" ></svg>
  <svg id="bubble" height="400" width="900"></svg>
  <svg id="genreBar" height="400" width="900"></svg>
  <svg id="barchart" height="500" width="800" style="background:black"></svg>

    <script>

    // Setting up the map
    const svg = d3.select("#choropleth");
    const slider = d3.select('div#slider');
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 40, left:20};
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
                    .attr("transform","translate("+margin.left+","+margin.top+")");

    // Setting up the bubble chart
    const bubble = d3.select("#bubble");
    const bWidth = bubble.attr("width");
    const bHeight = bubble.attr("height");
    const bMargin = { top: 20, right: 10, bottom: 10, left:10};
    const chartWidth = bWidth - bMargin.left - bMargin.right;
    const chartHeight = bHeight - bMargin.top - bMargin.bottom;
    const bubbleChart = bubble.append("g")
                    .attr("transform","translate("+bMargin.left+","+bMargin.top+")");

    // Setting up the genre bar chart
    const genreBar = d3.select("#genreBar");
    const gWidth = genreBar.attr("width");
    const gHeight = genreBar.attr("height");
    const gMargin = { top: 30, right: 10, bottom: 20, left:10};
    const genreWidth = gWidth - gMargin.left - gMargin.right;
    const genreHeight = gHeight - gMargin.top - gMargin.bottom;
    const genreChart = genreBar.append("g")
                    .attr("transform","translate("+gMargin.left+","+gMargin.top+")");
    let annotations = genreBar.append("g").attr("id","annotations");
    
    //rating bar chart
    const rating_svg = d3.select("#barchart");
    const width2 = rating_svg.attr("width");
    const height2 = rating_svg.attr("height");
    const margin2 = { top: 50, right: 50, bottom: 20, left:60};
    const ratingWidth = width2 - margin2.left - margin2.right;
    const ratingHeight = height2  - margin2.top - margin2.bottom;
    const rating_barchart = rating_svg.append("g")
                    .attr("transform","translate("+margin2.left+","+margin2.top+")");


    const requestData = async function (){

      // world countries data
      var countries_topo = await d3.json("./countries-110m.json");

      // filter out Antarctica and Greenland
      var filtered_countries = countries_topo.objects.countries.geometries;
      filtered_countries = filtered_countries.filter(
        d => d.properties.name !== "Antarctica" &&  d.properties.name !== "Greenland"
      );
      countries_topo.objects.countries.geometries = filtered_countries;

      //  projection and path for world countries
      var countries = topojson.feature(countries_topo, countries_topo.objects.countries);
      var countriesMesh = topojson.mesh(countries_topo, countries_topo.objects.countries);
      var landMesh = topojson.mesh(countries_topo, countries_topo.objects.land);
      // console.log("countries", countries);


      var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);
      var graticule = d3.geoGraticule10();
      // map.append("path").attr("class","graticule").attr("d", path(graticule) )

      // clean netflix data
      const netflix_titles = await d3.csv("./netflix_titles.csv");
      console.log(netflix_titles);

      // year added extent
      const year_added_extent = d3.extent(netflix_titles, d => d.date_added.split(', ')[1]);
      // console.log("added year extent", year_added_extent)


      // create a dictionary for each valid year called data, in the form of
      // data = {... 2019:{num_titles:30, num_countries:2, count:{country:20, country2:10}}...}
      var data = {};
      for (i = year_added_extent[0]; i <= year_added_extent[1]; i++) {
        data[i] = {};
        data[i]["num_titles"] = 0;
        data[i]["num_countries"] = 0;
        data[i]["num_genres"] = 0;
        data[i]["num_ratings"] = 0;
        data[i]["countriesCount"] = {};
        data[i]["genresCount"] = {};
        data[i]["ratingsCount"] = {};
      }

      // initiate data for all years
      data['All_year'] = {};
      data['All_year']["num_titles"] = 0;
      data['All_year']["num_countries"] = 0;
      data['All_year']["num_genres"] = 0;
      data['All_year']["num_ratings"] = 0;
      data['All_year']["countriesCount"] = {};
      data['All_year']["genresCount"] = {};
      data['All_year']["ratingsCount"] = {};

      netflix_titles.forEach( (d, i) => {
        if ((d.country === "")|| (d.date_added === "") || (d['listed_in'] === "")|| (d.rating === ""))  {
          netflix_titles.splice(i, 1);
        }
        else {
          year_added = d.date_added.split(', ')[1];
          data[year_added]["num_titles"] += 1;
          data['All_year']["num_titles"] += 1;

          let release_countries = (d.country).split(', ');
          let dict = data[year_added]["countriesCount"];
          let dict_all = data['All_year']["countriesCount"];
          release_countries.forEach( (country, i) => {
            if (country === "United States") country = "United States of America";
            if (country === "Czech Republic") country = "Czechia";
            if (country in dict){
              dict[country] += 1;
            } else{
              dict[country] = 1;
              data[year_added]["num_countries"] += 1;
            };
            if (country in dict_all){
              dict_all[country] += 1;
            } else{
              dict_all[country] = 1;
              data['All_year']["num_countries"] += 1;
            };
          });

          let genres = d['listed_in'].split(", ");
          let genreDict = data[year_added]["genresCount"];
          let genreDict_all = data["All_year"]["genresCount"];
          genres.forEach( (genre,i) => {
            if (genre in genreDict) {
              genreDict[genre] += 1;
            }
            else {
              genreDict[genre] = 1;
              data[year_added]["num_genres"] += 1;
            };
            if (genre in genreDict_all) {
              genreDict_all[genre] += 1;
            }
            else {
              genreDict_all[genre] = 1;
              data['All_year']["num_genres"] += 1;
            };
          });

          let rating = d.rating;
          let ratingDict = data[year_added]["ratingsCount"];
          if (rating in ratingDict) {
            ratingDict[rating] += 1;
          }
          else {
            ratingDict[rating] = 1;
            data[year_added]["num_ratings"] += 1;
          };

          //count rating for whole years
          let Allyear_ratingDict = data['All_year']["ratingsCount"];
          if (rating in Allyear_ratingDict) {
            Allyear_ratingDict[rating] += 1;
          }
          else {
            Allyear_ratingDict[rating] = 1;
            data['All_year']['num_ratings']+=1;
          };
        };
      });

      // console.log(data);

      for (const year_added in data) {
        for (const genresCount in year_added) {
            var topFive = Object.keys(data[year_added]["genresCount"]).map(function(key) {
                return [key, data[year_added]["genresCount"][key]];
            });
            
            topFive.sort(function(first, second) {
                return second[1] - first[1];
            });
        }
        // console.log(year_added, topFive.slice(0, 5));
        };

      // console.log("final data", data);

      // draw countries
      map.selectAll("path.country")
         .data(countries.features.filter(d => d.properties.name !== "Antarctica"
                                     &&  d.properties.name !== "Greenland"))
         .join("path")
         .attr("class", "country")
         .attr("note", (d, i) => d.properties.name )
         .attr("d", path);

      map.append("path").datum(countriesMesh)
         .attr("class","outline")
         .attr("d", path);

      // Added year slider
      var dataTime = d3.range(2008, 2022).map(function(d) {
        return new Date(d, 4, 26);
      });

      var sliderTime = d3
        .sliderBottom()
        .min(d3.min(dataTime))
        .max(d3.max(dataTime))
        .step(1000 * 60 * 60 * 24 * 365)
        .width(800)
        .tickFormat(d3.timeFormat('%Y'))
        .tickValues(dataTime)
        .default(new Date(2021, 4, 26))
        .on('onchange', val => {
          let current_year = d3.timeFormat('%Y')(val);
          draw_map(current_year);
          d3.select('p#value-time').text(current_year);
          drawCircles(current_year);
          drawBars(current_year);
        });

      var Time = slider
        .append('svg')
        .attr('width', 900)
        .attr('height', 100)
        .append('g')
        .attr('transform', 'translate(30,30)');

      Time.call(sliderTime);
      d3.select('p#value-time').text(d3.timeFormat('%Y')(sliderTime.value()));

      slider.select('svg').append("text")
         .attr("x", 10)
         .attr("y", 10)
         .attr("class", "slider_label")
         .text("Use this slider to update all charts based on your year selection");

      // make colorscale based on title count in all years
      var total_minMax = [0,0];
      for (i = year_added_extent[0]; i <= year_added_extent[1]; i++) {
        let num_titles_values =  Object.values(data[i].countriesCount) ;
        let minMax = d3.extent(num_titles_values);
        if (minMax[1] > total_minMax[1]) total_minMax = [0, minMax[1]];
      };
      const colorScale = d => d3.interpolateReds( d3.scaleSymlog()
                                .domain([0, total_minMax[1]]).range([0,1])(d) );

      // draw map
      // interaction function based on selected year
      function draw_map(current_year){
        let current_data = data[current_year];
        let countries_count = current_data.countriesCount;
        map.selectAll(".country")
           .style("fill", d => colorScale(titles_count(d.properties.name, countries_count)) );
      };

      // default map is based on netflix data in 2021
      draw_map("2021");

      function titles_count (ctry, countries_count) {
        if (ctry in countries_count){
          count = countries_count[ctry];
        } else {
          count = 0;
        };
        return count;
      };

     // draw color legend
     var legend_x = d3.scaleSymlog()
                     .domain([0, total_minMax[1]])
                     .range([margin.left+mapWidth*0.05, margin.left+mapWidth*0.9]);

     map.append("g")
           .attr("transform", `translate(0,${height-margin.bottom})`)
           .attr("class", "legend_axis")
           .call(rampHorizontal(legend_x, colorScale))
           .call(d3.axisBottom(legend_x))
         .selectAll("text")
           .attr("dy", ".35em")
           .attr("transform", "rotate(50)")
           .style("text-anchor", "start");

     map.append("text")
        .attr("x", margin.left+mapWidth*0.04)
        .attr("y", height-margin.bottom-30)
        .attr("class", "legend_label")
        .text("Title count (per country):");

     // create title for bubble chart
     bubble.append("text")
                .attr("x", bWidth / 2)
                .attr("y", bMargin.top-5)
                .attr("text-anchor", "middle")
                .style("font-family" , "'Bebas Neue', cursive")
                .style("font-size", "20px")
                .style("fill", "white")
                .text("TOP 5 GENRES FOR SELECTED YEAR");
    
     // create title for genre bar chart
     genreBar.append("text")
                .attr("x", gWidth / 2)
                .attr("y", gMargin.top-5)
                .attr("text-anchor", "middle")
                .style("font-family" , "'Bebas Neue', cursive")
                .style("font-size", "20px")
                .style("fill", "white")
                .text("TOP 5 GENRES FOR SELECTED YEAR");
     
     // Calculate the top 5 genres for each year
     let genreObj = {};
     for (let year_added in data) {
        for (let genresCount in year_added) {
            var topFive = Object.keys(data[year_added]["genresCount"]).map(function(key) {
                return [key, data[year_added]["genresCount"][key]];
            });
            
            topFive.sort(function(first, second) {
                return second[1] - first[1];
            });
        }
        genreObj[year_added] = topFive.slice(0, 5);
      };
      console.log(genreObj)

      // default circles are based on 2021
      drawCircles(2021);
      
      // color of circles based on genre
      // const typeScale = d3.scaleOrdinal().domain(["genre1","genre2"]).range(["#color","#color"]);

      // draw circles
      function drawCircles (slideryear) {
        let bubblePack = d => d3.pack()
                                    .size([chartWidth,chartHeight])
                                    .padding(2)(d3.hierarchy({children:genreObj[slideryear]}).sum(d => d[1]))
        
        let root = bubblePack(genreObj[slideryear]);
        
        let node = bubbleChart.selectAll('circle.genre')
                                .data(root.children)
                                // .enter().append('g')
                                .join( enter => enter.append("circle").data( root.children, d => d.data )
                                                    .attr("class","genre")
                                                    .attr("r", d => d.r)
                                                    .style('fill','red')
                                                    .attr("label", d => d.data)
                                                    .attr("opacity", 0)
                                                    .call( enter => enter.transition().duration(200).attr("opacity",1)), 
                                        update => update.call( update => update.transition().duration(200).attr("opacity",1)
                                                        .attr("class","genre")
                                                        .attr("r", d => d.r)
                                                        .style('fill','red')
                                                        .attr("label", d => d.data) ),
                                        exit => exit.call( exit => exit.transition().duration(300).attr('opacity',0).remove() ) )
                                .attr('transform', d => `translate(${d.x}, ${d.y})`);

        let labels = bubbleChart.selectAll('text.label')
                                .data(root.children)
                                .join("text").attr("class","label")
                                .text(d => d.data)
                                // .text(d => d.data[0].substring(0,8))
                                .style("font-size",15)
                                .style("fill","white")
                                .attr('transform', d => `translate(${d.x-20}, ${d.y})`);
      }

    // .data.name.substring(0, d.r / 3)

    // genre bar chart
    let bottomAxis = d3.axisBottom()
    let bottomAxisG = annotations.append("g")
                           .attr("class", "x axis")
                           .attr("transform",`translate(${gMargin.left},${genreHeight+gMargin.top})`)
    drawBars(2021);
    // let maxGenres = d3.max(genreObj, d => {return Math.max(d[0][0])})
    // console.log(maxGenre)
    function drawBars (slideryear) {
    let genres = d3.map(genreObj[slideryear], d => d[0]) 
    let genreScale = d3.scaleBand().domain(genres).range([0, genreWidth])
                                     .padding(0.05);
    bottomAxis.scale(genreScale)
    bottomAxisG.transition().duration(200).call(bottomAxis);

    let genreNumber = d3.scaleLinear()
          // .domain([0, d3.max(genreObj[slideryear], function(d){ return d[1]; })])
          .domain([0,623])
          .range([genreHeight,30]);

    genreChart.selectAll("rect.bar")
        .data(genreObj[slideryear])
        .join( enter => enter.append('rect')
                            .attr('class','bar')
                            .attr('fill','red')
                            .attr("x", d => genreScale(d[0]))
                            .attr("y", d => genreNumber(d[1]))
                            .attr("height", d => genreNumber(0) - genreNumber(d[1]))
                            .attr("width", genreScale.bandwidth() )
                            .attr("opacity", 0)
                            .call( enter => enter.transition().duration(200).attr("opacity",1)), 
                update => update.call( update => update.transition().duration(200).attr("opacity",1)
                                                .attr('fill','red')
                                                .attr("x", d => genreScale(d[0]))
                                                .attr("y", d => genreNumber(d[1]))
                                                .attr("height", d => genreNumber(0) - genreNumber(d[1]))
                                                .attr("width", genreScale.bandwidth() )),
                exit => exit.call( exit => exit.transition().duration(200).attr('opacity',0).remove() ) ); 

    genreChart.selectAll('text.label')
        .data(genreObj[slideryear])
        .join("text").attr("class","label")
        .text(d => d[1])
        .style("font-size",15)
        .style("fill","white")
        .attr("x",d => genreScale(d[0]) + genreScale.bandwidth()/2)
        .attr('y',d => genreNumber(d[1])-5);
      
    }
      //bar chart
      //dict => array
      let Allyear_ratingDict = data['All_year']['ratingsCount']
      // console.log(Object.entries(Allyear_ratingDict))
      let ratingArray = [];
      for (const [rating, value] of Object.entries(Allyear_ratingDict)) {
        ratingArray.push({
          'rating': rating,
          'value': value
        })
      }
      // console.log(ratingArray)
      ratingArray = ratingArray.sort(function (a, b) {
            return d3.ascending(a.value, b.value);
        })

      var y = d3.scaleBand()
          .domain(ratingArray.map(function(d) { return d.rating; }))
          .range([ratingHeight, 0])
          .padding(0.1);

      var x = d3.scaleLinear()
          .domain([0, d3.max(ratingArray, function(d){ return d.value; })])
          .range([0, ratingWidth]);

      var bars = rating_barchart.selectAll(".bar")
        .data(ratingArray)
        .enter()
        .append("g");

      bars.append("rect").attr("class", "bar")
        .attr("width", function(d) {return x(d.value); } )
        .attr("y", function(d) { return y(d.rating); })
        .attr("height", y.bandwidth());

      let leftAxis = d3.axisLeft(y).tickSize(0);
      rating_barchart.append("g")
                .attr("class", "y axis")
                .attr("color", 'white')
                .call(leftAxis);

      bars.append("text")
        .attr("class", "value")
        .text(function(d) {return d.value;})
        .attr("x", function(d){ return x(d.value) + 15;})
        .attr("y", function(d){return y(d.rating) + y.bandwidth() * (0.5 + 0.1);})
        .style("font-family" , "Arial")
        .style("font-size", "13px")
        .style("fill", "white")
        .attr("text-anchor", "middle");

       // add title
       rating_svg.append("text")
                .attr("x", width2 / 2)
                .attr("y", margin2.top / 2 )
                .attr("text-anchor", "middle")
                .style("font-family" , "Arial")
                .style("font-size", "20px")
                .style("fill", "white")
                .text("MOVIE AND TV SHOWS BY RATING");


    }
    requestData();
    </script>

</body>

</html>
